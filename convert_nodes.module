<?php
/**
 * Implements hook_install().
 *
function convert_nodes_uninstall() {
  //set this up so we could make a form later
  $bundle_from = 'policy';
  $bundle_to = 'documentation';
  // Get the names of the field tables.
  $entityManager = \Drupal::service('entity_field.manager');
  $fields_from = $entityManager->getFieldDefinitions('node', $bundle_from);
  $fields_to = $entityManager->getFieldDefinitions('node', $bundle_to);
echo "<pre>";
exit(print_r($fields_to));
  // get missing fields
  $fields_from_names = [];
  $fields_to_names = [];
  foreach ($fields_from as $field) {
    $fields_from_names[] = $field->getName();
  }
  foreach ($fields_to as $field) {
    $fields_to_names[] = $field->getName();
  }
  //convert these to a form for mapping
  $missing_from_fields = array_diff($fields_from_names,$fields_to_names);
  $missing_to_fields = array_diff($fields_to_names,$fields_from_names);
  // would be generated from missing. others would be automapped?
  $map_fields = array(
    //from => to
    'field_policy_end' => ['field' => 'field_date'],
    'field_policy_context' => ['field' => 'remove'],
    'field_policy_scope' => ['field' => 'append_to_body'],
    'field_policy_senior_manager' => ['field' => 'remove'],
    'field_policy_start' => ['field' => 'remove'],
    'field_policy_workflow' => ['field' => 'remove'],
    'field_senior_manager' => ['field' => 'remove'],
    //TODO make value editable and convert to field object
    'create_new' => ['field' => 'field_type_of_documentation','value' => $bundle_from],
  );

  $storage = \Drupal::service('entity_type.manager')->getStorage('node');
  // Get the names of the base tables.
  $base_table_names = [];
  $base_table_names[] = $storage->getBaseTable();
  $base_table_names[] = $storage->getDataTable();

  $table_mapping = \Drupal::service('entity_type.manager')->getStorage('node')->getTableMapping();
  $field_table_names = [];
  foreach ($fields_from as $key => $field) {
    if($field->getFieldStorageDefinition()->isBaseField() == FALSE) {
//if(!empty($field->getFieldStorageDefinition()->getPropertyDefinitions())){
exit(print_r($field->getFieldStorageDefinition()->getPropertyDefinition('value')->getDataType()));
//}
}
}
}
/*
      $field_name = $field->getName();
      $field_table = $table_mapping->getFieldTableName($field_name);
      $field_table_names[$field_name] = $field_table;
      $field_storage_definition = $field->getFieldStorageDefinition();
      $field_revision_table = $table_mapping->getDedicatedRevisionTableName($field_storage_definition);
      // Field revision tables DO have the bundle!
      $field_table_names[$field_name.'_revision'] = $field_revision_table;
    }
  }

  // Get the node IDs to update.
  $query = \Drupal::service('entity.query')->get('node');
  $query->condition('type', $bundle_from);
  $nids = $query->execute();

  $db = \Drupal\Core\Database\Database::getConnection();
  
  // get old fields
  foreach ($nids as $vid => $nid) {
    $node = \Drupal\node\Entity\Node::load($nid);
    foreach ($map_fields as $map_from => $map_to) {
      if ($map_to['field'] == 'remove' || $map_from == 'create_new') { continue; }
      $map_fields[$map_from]['value'] = $node->get($map_from)->getValue();
    }
  }

  // Base tables have 'nid' and 'type' columns.
  foreach ($base_table_names as $table_name) {
    $db->update($table_name)
      ->fields(['type' => $bundle_to])
      ->condition('nid', $nids, 'IN')
      ->execute();
  }

  // Field tables have 'entity_id' and 'bundle' columns.
  foreach ($field_table_names as $field_name => $table_name) {
    if (!in_array(str_replace('_revision','',$field_name),$missing_from_fields)) {
      $db->update($table_name)
        ->fields(['bundle' => $bundle_to])
        ->condition('entity_id', $nids, 'IN')
        ->execute();
    }
  }

  //flush cache so we recognize new bundle type now
  drupal_flush_all_caches();
  // add new fields
  foreach ($nids as $vid => $nid) {
    $node = \Drupal\node\Entity\Node::load($nid);
    foreach ($map_fields as $map_from => $map_to) {
      if ($map_to['field'] == 'remove') { continue; }
      if ($map_from == 'create_new') {
        $node->get($map_to['field'])->setValue([['value' => $map_to['value']]]);
      }
      else if ($map_to['field'] == 'append_to_body') {
        $body = $node->get('body')->getValue();
        $node->get('body')->setValue([['value' => $body.$map_to['value']]]);
      }
      else {
        $node->get($map_to['field'])->setValue($map_to['value']);
      }
    }
  }
    /*
    $db->insert('node__field_type_of_documentation')
      ->fields(array(
        'bundle' => $bundle_to,
        'deleted' => 0,
        'entity_id' => $nid,
        'revision_id' => $vid,
        'langcode' => 'en',
        'delta' => 0,
        'field_type_of_documentation_value' => $bundle_from,
      ))
      ->execute();
      */

/*
  $db = \Drupal\Core\Database\Database::getConnection();
  $query = $db->select('node')
    ->fields('node', array('nid','type','vid'))
    ->condition('node.type', 'policy', '=');
  $nids = $query->execute()->fetchAll(\PDO::FETCH_OBJ);
  $tables_to_update = array(
    'type' => array('node','node_field_data'),
    node__body, node__comment, node__field_associated_with, node__field__authors
    'bundle' => array()
  );
  foreach ($nids as $nid) {
    $db->update('')
      ->condition('bundle', 'policy')
      ->fields(array(
      
      ))
      
    $db->insert('node__field_type_of_documentation')
      ->fields(array(
        'bundle' => 'policy',
        'deleted' => 0,
        'entity_id' => $nid->nid,
        'revision_id' => $nid->vid,
        'langcode' => 'en',
        'delta' => 0,
        'field_type_of_documentation_value' => 'policy',
      ))
      ->execute();
  }
*/
//}